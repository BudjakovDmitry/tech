# SOLID

## Введение

Принципы SOLID касаются проектирования ПО. Под проектом программы Роберт Мартин называет
исходный код.

Требования к программным продуктам часто меняются. А значит нужно часто менять проект
(код). Инженерам нужно максимизировать простоту поддержки кода (чистота кода).

### Запахи кода

Чтобы определить чистый код или нет, нужно видеть признаки гнилого кода (запахи кода).
Выделяют пять фундаментальных запахов кода:

- Ригидность (Rigidity);
- Хрупкость (Fragility);
- Неподвижность (Immobility);
- Вязкость (Viscosity);
- Излишняя сложность (Needless Complexity);

ПО является **ригидным**, если цена внесения одного изменения очень высока.

Основной источник ригидности - высокая связанность между модулями.

**Хрупкое** является ПО, в котором изменения в одном модуле вызывают появление ошибок в
других модулях.

Основной источник хрупкости - плохо спроектированные отношения между модулями. Чтобы
преодолеть хрупкость, нужно изолировать зависимости друг от друга.

ПО является **неподвижным**, когда его компоненты нельзя повторно использовать в других
системах.

Этот запах скорей всего вызван плотной связью между модулями. Чтобы побороть его нужно
грамотно разделить или изолировать модули.

В **вязком** ПО при добавлении одной функции приходится взаимодействовать со множеством
аспектов, в том числе на разных уровнях.

На практике этот запах можно обнаружить по трудностям при работе с системой контроля
версий. Это происходит из-за того, что приходится вносить слишком много изменений в
разных частях кода.

ПО является **излишне сложным**, когда разработчики, пытаясь спрогнозировать будущее,
вводят излишние точки расширения, там где они не нужны.

Почти все запахи связаны с плохо организованным менеджментом зависимостей. Из этого
можно сделать вывод, что ключом к хорошей архитектуре является грамотный менеджмент
зависимостей.

## Принципы SOLID

Это пять принципов, которые можно назвать принципами менеджмента зависимостей.

- Single Responsibility Principle (SRP);
- Open Closed Principle (OCP);
- Liskov Substitution Principle;
- Interface Segregation Principle;
- Dependency Inversion Principle;
